<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Bin Packing Visualization</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
            overflow: hidden;
            /* Á¶ÅÁî®ÊñáÊú¨ÈÄâÊã©ÂíåÊãñÊãΩ */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-user-drag: none;
            -khtml-user-drag: none;
            -moz-user-drag: none;
            -o-user-drag: none;
            user-drag: none;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            max-width: 300px;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
        }
        
        .stats-row {
            margin: 5px 0;
        }
        
        .control-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .control-button:hover {
            background: #45a049;
        }
        
        .item-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">Loading visualization...</div>
        
        <div id="info-panel" style="display: none;">
            <h3>üì¶ Bin Packing Stats</h3>
            <div id="stats"></div>
            <h4>üìã Items</h4>
            <div id="items-list"></div>
        </div>
        
        <div id="controls" style="display: none;">
            <h4>üéÆ Controls</h4>
            <button class="control-button" onclick="resetView()">Reset View</button>
            <button class="control-button" onclick="toggleWireframe()">Toggle Wireframe</button>
            <button class="control-button" onclick="toggleAxes()">Toggle Axes</button>
            <div style="margin-top: 10px; font-size: 12px;">
                ‚Ä¢ Left drag: Rotate<br>
                ‚Ä¢ Middle drag: Pan<br>
                ‚Ä¢ Mouse wheel: Zoom In/Out<br>
                ‚Ä¢ Touch: Mobile support
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        let scene, camera, renderer;
        let wireframeEnabled = false;
        let axesHelper;
        let mouseX = 0, mouseY = 0;
        let isMouseDown = false;
        let isMiddleMouseDown = false;
        let isRightMouseDown = false;
        let rightClickTimer = null;
        let targetX = 0, targetY = 0;
        let containerSize = 100;
        let cameraDistance = 200; // Áõ∏Êú∫Ë∑ùÁ¶ªÁõÆÊ†áÁöÑË∑ùÁ¶ª
        let minDistance = 50;     // ÊúÄÂ∞èË∑ùÁ¶ª
        let maxDistance = 1000;   // ÊúÄÂ§ßË∑ùÁ¶ª
        let panOffset = { x: 0, y: 0, z: 0 };  // Âπ≥ÁßªÂÅèÁßªÈáè
        let lookAtTarget = { x: 0, y: 0, z: 0 }; // ËßÜÁ∫øÁõÆÊ†áÁÇπ
        
        // Sample data for testing if JSON fails to load
        function getSampleData() {
            return {
                "container": {
                    "length": 100,
                    "width": 80,
                    "height": 60
                },
                "items": [
                    {
                        "id": 1,
                        "dimensions": { "length": 30, "width": 20, "height": 15 },
                        "position": { "x": 0, "y": 0, "z": 0 },
                        "color": "#ff6b6b"
                    },
                    {
                        "id": 2,
                        "dimensions": { "length": 25, "width": 25, "height": 20 },
                        "position": { "x": 30, "y": 0, "z": 0 },
                        "color": "#4ecdc4"
                    },
                    {
                        "id": 3,
                        "dimensions": { "length": 20, "width": 30, "height": 10 },
                        "position": { "x": 0, "y": 20, "z": 0 },
                        "color": "#45b7d1"
                    }
                ],
                "stats": {
                    "totalItems": 3,
                    "containerVolume": 480000,
                    "itemsVolume": 24000,
                    "utilizationRate": 5.0
                }
            };
        }
        
        async function init() {
            console.log('Starting initialization...');
            
            // Check if Three.js loaded properly
            if (typeof THREE === 'undefined') {
                document.getElementById('loading').textContent = 'Failed to load Three.js library. Please check your internet connection.';
                console.error('Three.js not loaded');
                return;
            }
            console.log('Three.js loaded successfully');
            
            let data;
            try {
                console.log('Attempting to fetch bin_packing_3d.json...');
                const response = await fetch('bin_packing_3d.json');
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                data = await response.json();
                console.log('Successfully loaded JSON data:', data);
                document.getElementById('loading').style.display = 'none';
            } catch (error) {
                console.warn('Failed to load bin_packing_3d.json:', error.message);
                console.log('Using sample data instead...');
                data = getSampleData();
                
                // Update loading message
                document.getElementById('loading').innerHTML = `
                    <div style="color: orange;">‚ö†Ô∏è Could not load bin_packing_3d.json</div>
                    <div style="font-size: 14px; margin-top: 5px;">Showing sample data instead</div>
                `;
                
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 2000);
            }
            
            try {
                document.getElementById('info-panel').style.display = 'block';
                document.getElementById('controls').style.display = 'block';
                
                setupScene(data);
                setupMouseControls();
                updateUI(data);
                animate();
                
                console.log('Visualization setup complete');
            } catch (error) {
                console.error('Error setting up visualization:', error);
                document.getElementById('loading').innerHTML = `
                    <div style="color: red;">‚ùå Error setting up 3D scene</div>
                    <div style="font-size: 12px; margin-top: 5px;">${error.message}</div>
                `;
            }
        }
        
        function setupScene(data) {
            console.log('Setting up 3D scene...');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Remove existing canvas if any
            const existingCanvas = document.querySelector('#container canvas');
            if (existingCanvas) {
                existingCanvas.remove();
            }
            
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Â¢ûÂº∫ÁéØÂ¢ÉÂÖâÔºåËÆ©ÊâÄÊúâÈù¢ÈÉΩÊúâË∂≥Â§üÁöÑÁÖßÊòé
            const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
            scene.add(ambientLight);
            
            // ‰∏ªÂÖâÊ∫ê
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight1.position.set(50, 50, 50);
            directionalLight1.castShadow = true;
            scene.add(directionalLight1);
            
            // Ê∑ªÂä†ËÉåÈù¢ÂÖâÊ∫êÔºåÁÖß‰∫ÆÈò¥ÂΩ±Èù¢
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-50, -50, -50);
            scene.add(directionalLight2);
            
            // Ê∑ªÂä†‰æßÈù¢ÂÖâÊ∫ê
            const directionalLight3 = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight3.position.set(50, -50, 50);
            scene.add(directionalLight3);
            
            // Ê∑ªÂä†Âè¶‰∏Ä‰æßÈù¢ÂÖâÊ∫ê
            const directionalLight4 = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight4.position.set(-50, 50, 50);
            scene.add(directionalLight4);
            
            containerSize = Math.max(data.container.length, data.container.width, data.container.height);
            axesHelper = new THREE.AxesHelper(containerSize * 0.6);
            scene.add(axesHelper);
            
            createContainer(data.container);
            data.items.forEach((item, index) => {
                console.log(`Creating item ${index + 1}:`, item);
                createItem(item);
            });
            
            // Set initial camera position and distance
            cameraDistance = containerSize * 2;
            minDistance = containerSize * 0.5;
            maxDistance = containerSize * 5;
            
            // ËÆæÁΩÆÂàùÂßãËßÇÂØüÁõÆÊ†á‰∏∫ÂÆπÂô®‰∏≠ÂøÉ
            lookAtTarget.x = data.container.length / 2;
            lookAtTarget.y = data.container.width / 2;
            lookAtTarget.z = data.container.height / 2;
            
            updateCameraPosition();
            
            console.log('3D scene setup complete');
        }
        
        function setupMouseControls() {
            const canvas = renderer.domElement;
            
            canvas.addEventListener('mousedown', onMouseDown, false);
            canvas.addEventListener('mousemove', onMouseMove, false);
            canvas.addEventListener('mouseup', onMouseUp, false);
            canvas.addEventListener('wheel', onMouseWheel, false);
            
            // Á¶ÅÁî®‰∏≠ÈîÆÁöÑÈªòËÆ§Ë°å‰∏∫ÔºàÊØîÂ¶ÇÂú®Êüê‰∫õÊµèËßàÂô®‰∏≠ÊâìÂºÄÈìæÊé•Ôºâ
            canvas.addEventListener('auxclick', (event) => {
                if (event.button === 1) event.preventDefault();
            }, false);
            
            // ÂΩªÂ∫ïÁ¶ÅÁî®Âè≥ÈîÆÁõ∏ÂÖ≥Ë°å‰∏∫
            canvas.addEventListener('contextmenu', (event) => {
                event.preventDefault();
                event.stopPropagation();
                return false;
            }, false);
            
            // Á¶ÅÁî®ÊãñÊãΩÂºÄÂßã‰∫ã‰ª∂ÔºàÂåÖÊã¨Âè≥ÈîÆÊãñÊãΩÔºâ
            canvas.addEventListener('dragstart', (event) => {
                event.preventDefault();
                event.stopPropagation();
                return false;
            }, false);
            
            // Á¶ÅÁî®ÈÄâÊã©ÊñáÊú¨
            canvas.addEventListener('selectstart', (event) => {
                event.preventDefault();
                event.stopPropagation();
                return false;
            }, false);
            
            // È¢ùÂ§ñÁöÑÂè≥ÈîÆÈïøÊåâ‰øùÊä§
            canvas.addEventListener('pointerdown', (event) => {
                if (event.button === 2) {
                    event.preventDefault();
                    event.stopPropagation();
                    return false;
                }
            }, false);
            
            canvas.addEventListener('pointerup', (event) => {
                if (event.button === 2) {
                    event.preventDefault();
                    event.stopPropagation();
                    return false;
                }
            }, false);
            
            // Á¶ÅÁî®ÈïøÊåâÊâãÂäøÔºà‰∏ªË¶ÅÈíàÂØπÁßªÂä®ËÆæÂ§áÔºâ
            canvas.addEventListener('touchstart', (event) => {
                if (event.touches.length > 1) {
                    event.preventDefault();
                    return false;
                }
            }, { passive: false });
            
            canvas.addEventListener('gesturestart', (event) => {
                event.preventDefault();
                return false;
            }, false);
            
            // Touch events for mobile
            canvas.addEventListener('touchstart', onTouchStart, false);
            canvas.addEventListener('touchmove', onTouchMove, false);
            canvas.addEventListener('touchend', onTouchEnd, false);
        }
        
        function onMouseDown(event) {
            if (event.button === 0) { // Â∑¶ÈîÆ
                isMouseDown = true;
            } else if (event.button === 1) { // ‰∏≠ÈîÆ
                isMiddleMouseDown = true;
                event.preventDefault(); // Èò≤Ê≠¢ÈªòËÆ§ÁöÑ‰∏≠ÈîÆË°å‰∏∫
            } else if (event.button === 2) { // Âè≥ÈîÆ
                isRightMouseDown = true;
                event.preventDefault(); // Á¶ÅÁî®Âè≥ÈîÆË°å‰∏∫
                event.stopPropagation();
                
                // Ê∏ÖÈô§‰πãÂâçÁöÑÂÆöÊó∂Âô®
                if (rightClickTimer) {
                    clearTimeout(rightClickTimer);
                }
                
                // ËÆæÁΩÆÈïøÊåâÊ£ÄÊµãÂÆöÊó∂Âô®
                rightClickTimer = setTimeout(() => {
                    if (isRightMouseDown) {
                        console.log('ÈïøÊåâÂè≥ÈîÆË¢´ÈòªÊ≠¢');
                        // Âº∫Âà∂Ëß¶ÂèëmouseupÊù•ÁªìÊùüÂè≥ÈîÆÁä∂ÊÄÅ
                        isRightMouseDown = false;
                    }
                }, 100); // 100msÂêéËÆ§‰∏∫ÊòØÈïøÊåâ
                
                return false;
            }
            mouseX = event.clientX;
            mouseY = event.clientY;
        }
        
        function onMouseMove(event) {
            // Â¶ÇÊûúÂè≥ÈîÆË¢´Êåâ‰∏ãÔºåÈòªÊ≠¢ÊâÄÊúâÁßªÂä®Ë°å‰∏∫
            if (isRightMouseDown) {
                event.preventDefault();
                event.stopPropagation();
                return false;
            }
            
            if (!isMouseDown && !isMiddleMouseDown) return;
            
            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;
            
            if (isMouseDown) {
                // Â∑¶ÈîÆÊãñÊãΩ - ÊóãËΩ¨
                targetX += deltaX * 0.01;
                targetY += deltaY * 0.01;
            } else if (isMiddleMouseDown) {
                // ‰∏≠ÈîÆÊãñÊãΩ - Âπ≥Áßª
                const panSpeed = cameraDistance * 0.001;
                
                // ËÆ°ÁÆóÁõ∏Êú∫ÁöÑÂè≥ÊñπÂêëÂíå‰∏äÊñπÂêëÂêëÈáè
                const rightVector = new THREE.Vector3();
                const upVector = new THREE.Vector3();
                
                camera.getWorldDirection(new THREE.Vector3());
                rightVector.setFromMatrixColumn(camera.matrixWorld, 0);
                upVector.setFromMatrixColumn(camera.matrixWorld, 1);
                
                // Â∫îÁî®Âπ≥Áßª
                panOffset.x -= rightVector.x * deltaX * panSpeed;
                panOffset.y += upVector.y * deltaY * panSpeed;
                panOffset.z -= rightVector.z * deltaX * panSpeed;
                
                // Êõ¥Êñ∞ËßÇÂØüÁõÆÊ†áÁÇπ
                lookAtTarget.x -= rightVector.x * deltaX * panSpeed;
                lookAtTarget.y += upVector.y * deltaY * panSpeed;
                lookAtTarget.z -= rightVector.z * deltaX * panSpeed;
            }
            
            mouseX = event.clientX;
            mouseY = event.clientY;
        }
        
        function onMouseUp(event) {
            if (event.button === 0) { // Â∑¶ÈîÆ
                isMouseDown = false;
            } else if (event.button === 1) { // ‰∏≠ÈîÆ
                isMiddleMouseDown = false;
            } else if (event.button === 2) { // Âè≥ÈîÆ
                isRightMouseDown = false;
                
                // Ê∏ÖÈô§ÈïøÊåâÂÆöÊó∂Âô®
                if (rightClickTimer) {
                    clearTimeout(rightClickTimer);
                    rightClickTimer = null;
                }
                
                event.preventDefault(); // Á¶ÅÁî®Âè≥ÈîÆË°å‰∏∫
                event.stopPropagation();
                return false;
            }
        }
        
        function onMouseWheel(event) {
            event.preventDefault();
            
            // ÊªöËΩÆÁº©ÊîæÔºåÂêë‰∏äÊªöÂä®Áº©Â∞èË∑ùÁ¶ª(ÊîæÂ§ß)ÔºåÂêë‰∏ãÊªöÂä®Â¢ûÂä†Ë∑ùÁ¶ª(Áº©Â∞è)
            const zoomSpeed = 0.1;
            const delta = event.deltaY > 0 ? 1 + zoomSpeed : 1 - zoomSpeed;
            
            cameraDistance *= delta;
            
            // ÈôêÂà∂Áº©ÊîæËåÉÂõ¥
            cameraDistance = Math.max(minDistance, Math.min(maxDistance, cameraDistance));
            
            console.log(`Camera distance: ${cameraDistance.toFixed(2)} (min: ${minDistance}, max: ${maxDistance})`);
        }
        
        function onTouchStart(event) {
            if (event.touches.length === 1) {
                mouseX = event.touches[0].clientX;
                mouseY = event.touches[0].clientY;
                isMouseDown = true;
            }
        }
        
        function onTouchMove(event) {
            if (event.touches.length === 1 && isMouseDown) {
                const deltaX = event.touches[0].clientX - mouseX;
                const deltaY = event.touches[0].clientY - mouseY;
                
                targetX += deltaX * 0.01;
                targetY += deltaY * 0.01;
                
                mouseX = event.touches[0].clientX;
                mouseY = event.touches[0].clientY;
            }
        }
        
        function onTouchEnd(event) {
            isMouseDown = false;
        }
        
        function createContainer(container) {
            console.log('Creating container:', container);
            const geometry = new THREE.BoxGeometry(container.length, container.width, container.height);
            const edges = new THREE.EdgesGeometry(geometry);
            const material = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            const wireframe = new THREE.LineSegments(edges, material);
            wireframe.position.set(container.length / 2, container.width / 2, container.height / 2);
            scene.add(wireframe);
        }
        
        function createItem(item) {
            const geometry = new THREE.BoxGeometry(item.dimensions.length, item.dimensions.width, item.dimensions.height);
            const material = new THREE.MeshPhongMaterial({ 
                color: item.color,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide  // ÂèåÈù¢ÊùêË¥®ÔºåÁ°Æ‰øùÂÜÖÂ§ñÈù¢ÈÉΩÂèØËßÅ
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            
            // Support both uppercase and lowercase position field names
            const posX = item.position.X !== undefined ? item.position.X : item.position.x;
            const posY = item.position.Y !== undefined ? item.position.Y : item.position.y;
            const posZ = item.position.Z !== undefined ? item.position.Z : item.position.z;
            
            mesh.position.set(
                posX + item.dimensions.length / 2,
                posY + item.dimensions.width / 2,
                posZ + item.dimensions.height / 2
            );
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData = { item: item };
            scene.add(mesh);
            
            const edges = new THREE.EdgesGeometry(geometry);
            const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 });
            const wireframe = new THREE.LineSegments(edges, wireframeMaterial);
            wireframe.position.copy(mesh.position);
            scene.add(wireframe);
        }
        
        function updateUI(data) {
            const statsHtml = `
                <div class="stats-row"><strong>Items:</strong> ${data.stats.totalItems}</div>
                <div class="stats-row"><strong>Container Volume:</strong> ${data.stats.containerVolume.toLocaleString()}</div>
                <div class="stats-row"><strong>Items Volume:</strong> ${data.stats.itemsVolume.toLocaleString()}</div>
                <div class="stats-row"><strong>Space Utilization:</strong> ${data.stats.utilizationRate.toFixed(2)}%</div>
            `;
            document.getElementById('stats').innerHTML = statsHtml;
            
            const itemsHtml = data.items.slice(0, 8).map(item => {
                // Support both uppercase and lowercase position field names
                const posX = item.position.X !== undefined ? item.position.X : item.position.x;
                const posY = item.position.Y !== undefined ? item.position.Y : item.position.y;
                const posZ = item.position.Z !== undefined ? item.position.Z : item.position.z;
                
                return `
                    <div class="item-info" style="border-left: 4px solid ${item.color}">
                        <strong>Item ${item.id}:</strong> ${item.dimensions.length}√ó${item.dimensions.width}√ó${item.dimensions.height}<br>
                        <small>Position: (${posX}, ${posY}, ${posZ})</small>
                    </div>
                `;
            }).join('');
            document.getElementById('items-list').innerHTML = itemsHtml + 
                (data.items.length > 8 ? `<div style='text-align: center; margin-top: 10px;'>... and ${data.items.length - 8} more items</div>` : '');
        }
        
        function resetView() {
            targetX = 0;
            targetY = 0;
            cameraDistance = containerSize * 2;
            panOffset = { x: 0, y: 0, z: 0 };
            lookAtTarget = { x: 0, y: 0, z: 0 };
            updateCameraPosition();
        }
        
        function toggleWireframe() {
            wireframeEnabled = !wireframeEnabled;
            scene.children.forEach(child => {
                if (child.material && (child.material.type === 'MeshPhongMaterial' || child.material.type === 'MeshLambertMaterial')) {
                    child.material.wireframe = wireframeEnabled;
                }
            });
        }
        
        function toggleAxes() {
            axesHelper.visible = !axesHelper.visible;
        }
        
        function updateCameraPosition() {
            // Âü∫‰∫éÁêÉÂùêÊ†áÁ≥ªËÆ°ÁÆóÁõ∏Êú∫‰ΩçÁΩÆÔºåÂä†‰∏äÂπ≥ÁßªÂÅèÁßª
            camera.position.x = Math.cos(targetX) * Math.cos(targetY) * cameraDistance + panOffset.x;
            camera.position.y = Math.sin(targetY) * cameraDistance + panOffset.y;
            camera.position.z = Math.sin(targetX) * Math.cos(targetY) * cameraDistance + panOffset.z;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Êõ¥Êñ∞Áõ∏Êú∫‰ΩçÁΩÆ
            updateCameraPosition();
            camera.lookAt(lookAtTarget.x, lookAtTarget.y, lookAtTarget.z);
            
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Add error handling for window errors
        window.addEventListener('error', (e) => {
            console.error('JavaScript error:', e.error);
            document.getElementById('loading').innerHTML = `
                <div style="color: red;">‚ùå JavaScript Error</div>
                <div style="font-size: 12px; margin-top: 5px;">${e.error.message}</div>
            `;
        });
        
        // ÂÖ®Â±ÄÁ¶ÅÁî®Âè≥ÈîÆËèúÂçï
        document.addEventListener('contextmenu', (event) => {
            event.preventDefault();
            event.stopPropagation();
            return false;
        }, false);
        
        // ÂÖ®Â±ÄÁ¶ÅÁî®ÊãñÊãΩÂíåÈÄâÊã©
        document.addEventListener('dragstart', (event) => {
            event.preventDefault();
            event.stopPropagation();
            return false;
        }, false);
        
        document.addEventListener('selectstart', (event) => {
            if (event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
                event.preventDefault();
                event.stopPropagation();
                return false;
            }
        }, false);
        
        // ÂÖ®Â±ÄÂè≥ÈîÆÈïøÊåâ‰øùÊä§
        document.addEventListener('mousedown', (event) => {
            if (event.button === 2) {
                event.preventDefault();
                event.stopPropagation();
                return false;
            }
        }, true); // ‰ΩøÁî®ÊçïËé∑Èò∂ÊÆµ
        
        document.addEventListener('mouseup', (event) => {
            if (event.button === 2) {
                event.preventDefault();
                event.stopPropagation();
                return false;
            }
        }, true); // ‰ΩøÁî®ÊçïËé∑Èò∂ÊÆµ
        
        // Á¶ÅÁî®ÈïøÊåâÁõ∏ÂÖ≥ÁöÑ‰∫ã‰ª∂
        document.addEventListener('MSHoldVisual', (event) => {
            event.preventDefault();
            return false;
        }, false);
        
        document.addEventListener('MSGestureHold', (event) => {
            event.preventDefault();
            return false;
        }, false);
        
        init();
    </script>
</body>
</html> 